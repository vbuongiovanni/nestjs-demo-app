import { Test, TestingModule } from '@nestjs/testing';
import { plainToInstance } from 'class-transformer';
import { <%= classify(name) %>sController } from '../<%= dasherize(name) %>s.controller';
import { <%= classify(name) %>sService } from '../<%= dasherize(name) %>s.service';
import { <%= classify(name) %>sResponseDto } from '../<%= dasherize(name) %>s.dto';
import {
  create<%= classify(name) %>Stub,
  get<%= classify(name) %>Stub,
  get<%= classify(name) %>sStub,
  update<%= classify(name) %>Stub,
  delete<%= classify(name) %>Stub,
  create<%= classify(name) %>RequestBody,
  update<%= classify(name) %>RequestBody,
  test<%= classify(name) %>1Id,
} from './<%= dasherize(name) %>s.stub';

// this file was generated by nestjs/schematics - controller-spec

jest.mock('../<%= dasherize(name) %>s.service');

describe('<%= classify(name) %>Controller', () => {
  let controller: <%= classify(name) %>sController;
  let mockService: <%= classify(name) %>sService;

  beforeAll(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [<%= classify(name) %>sController],
      providers: [<%= classify(name) %>sService],
    }).compile();

    controller = module.get<<%= classify(name) %>sController>(<%= classify(name) %>sController);
    mockService = module.get<<%= classify(name) %>sService>(<%= classify(name) %>sService);

    jest.clearAllMocks();
  });

  describe('create<%= classify(name) %>', () => {
    describe('Given an authenticated user', () => {
      describe('When the user attempts to create a <%= classify(name) %>', () => {
        let response: <%= classify(name) %>sResponseDto;
        beforeEach(async () => {
          response = await controller.create<%= classify(name) %>(create<%= classify(name) %>RequestBody);
        });

        it('then it should call the create<%= classify(name) %> method of the <%= classify(name) %>sService', async () => {
          expect(mockService.create<%= classify(name) %>).toHaveBeenCalledWith(create<%= classify(name) %>RequestBody);
        });

        it('and it should return a <%= name %> in the shape of a DTO transformed object.', () => {
          const expectedResponse = plainToInstance(<%= classify(name) %>sResponseDto, create<%= classify(name) %>Stub(), { excludeExtraneousValues: true });
          expect(response).toEqual(expectedResponse);
        });
      });
    });
  });

  describe('get<%= classify(name) %>s', () => {
    describe('Given an authenticated user', () => {
      describe('When the user attempts to fetch all <%= classify(name) %>s', () => {
        let response: <%= classify(name) %>sResponseDto[];
        beforeEach(async () => {
          response = await controller.get<%= classify(name) %>s();
        });

        it('then it should call the get<%= classify(name) %> method of the <%= classify(name) %>sService', async () => {
          expect(mockService.get<%= classify(name) %>s).toHaveBeenCalledWith();
        });

        it('and it should return all <%= name %>s in the shape of a DTO transformed object.', () => {
          const expectedResponse = plainToInstance(<%= classify(name) %>sResponseDto, get<%= classify(name) %>sStub(), { excludeExtraneousValues: true });
          expect(response).toEqual(expectedResponse);
        });
      });
    });
  });

  describe('get<%= classify(name) %>', () => {
    describe('Given an authenticated user', () => {
      describe('When the user attempts to fetch a single <%= classify(name) %>', () => {
        let response: <%= classify(name) %>sResponseDto;
        beforeEach(async () => {
          response = await controller.get<%= classify(name) %>(test<%= classify(name) %>1Id);
        });

        it('then it should call the get<%= classify(name) %> method of the <%= classify(name) %>sService', async () => {
          expect(mockService.get<%= classify(name) %>).toHaveBeenCalledWith(test<%= classify(name) %>1Id);
        });

        it('and it should return a <%= name %> in the shape of a DTO transformed object.', () => {
          const expectedResponse = plainToInstance(<%= classify(name) %>sResponseDto, get<%= classify(name) %>Stub(), { excludeExtraneousValues: true });
          expect(response).toEqual(expectedResponse);
        });
      });
    });
  });

  describe('update<%= classify(name) %>', () => {
    describe('Given an authenticated user', () => {
      describe('When the user attempts to update a <%= classify(name) %>', () => {
        let response: <%= classify(name) %>sResponseDto;
        beforeEach(async () => {
          response = await controller.update<%= classify(name) %>(test<%= classify(name) %>1Id, update<%= classify(name) %>RequestBody);
        });

        it('then it should call the update<%= classify(name) %> method of the <%= classify(name) %>sService', async () => {
          expect(mockService.update<%= classify(name) %>).toHaveBeenCalledWith(test<%= classify(name) %>1Id, update<%= classify(name) %>RequestBody);
        });

        it('and it should return a <%= name %> in the shape of a DTO transformed object.', () => {
          const expectedResponse = plainToInstance(<%= classify(name) %>sResponseDto, update<%= classify(name) %>Stub(), { excludeExtraneousValues: true });
          expect(response).toEqual(expectedResponse);
        });
      });
    });
  });

  describe('delete<%= classify(name) %>', () => {
    describe('Given an authenticated user', () => {
      describe('When the user attempts to fetch a single <%= classify(name) %>', () => {
        let response: <%= classify(name) %>sResponseDto;
        beforeEach(async () => {
          response = await controller.delete<%= classify(name) %>(test<%= classify(name) %>1Id);
        });

        it('then it should call the delete<%= classify(name) %> method of the <%= classify(name) %>sService', async () => {
          expect(mockService.delete<%= classify(name) %>).toHaveBeenCalledWith(test<%= classify(name) %>1Id);
        });

        it('and it should return a <%= name %> in the shape of a DTO transformed object.', () => {
          const expectedResponse = plainToInstance(<%= classify(name) %>sResponseDto, delete<%= classify(name) %>Stub(), { excludeExtraneousValues: true });
          expect(response).toEqual(expectedResponse);
        });
      });
    });
  });
});
